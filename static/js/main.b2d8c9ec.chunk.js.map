{"version":3,"sources":["../../src/index.tsx","App.js","index.js"],"names":["doAfterRender","callback","timeout","setTimeout","clearTimeout","input","config","m","s","h","onDone","recuring","React.useState","count","setCount","started","setStarted","stop","diff","remainingMilliseconds","duration","asMilliseconds","shouldReset","isDone","delay","savedCallback","React.useRef","React.useEffect","current","id","setInterval","clearInterval","undefined","time","utc","start","App","useCountdown","console","warn","style","height","width","display","justifyContent","alignItems","flexDirection","format","marginTop","onClick","ReactDOM","render","document","getElementById"],"mappings":"2NA0BMA,EAAgB,SAACC,GACrB,IAAMC,EAAUC,YAAW,WACzBF,IACAG,aAAaF,KACZ,IAGQ,EAAe,SAC1BG,EACAC,QADA,IAAAD,MAAA,SACA,IAAAC,MAAA,IAEQ,MAAwBD,EAAnB,EAALE,OAAC,IAAG,IAAC,EAAE,EAAiBF,EAAZ,EAALG,OAAC,IAAG,IAAC,EAAE,EAAUH,EAAL,EAALI,OAAC,IAAG,IAAC,EACnB,EAA0CH,EAAvB,OAAnBI,OAAM,IAAG,aAAM,UAAI,EAAE,EAAqBJ,EAAL,SAAhBK,OAAQ,IAAG,GAAK,EAEvC,EAAoBC,mBAAe,GAAlCC,EAAK,KAAEC,EAAQ,KAChB,EAAwBF,oBAAe,GAAtCG,EAAO,KAAEC,EAAU,KAGpBC,EAAO,WAAM,OAAAD,GAAW,IAGxBE,EADmB,GAAJT,EAAS,GAAK,IAAW,GAAJF,EAAS,IAAW,IAAJC,EAC9BK,EAGtBM,EADoB,IAAOC,SAASF,EAAM,gBACAG,iBAE1CC,EAAcP,GAAqC,IAA1BI,GAA+BR,EACxDY,EAASR,GAAqC,IAA1BI,EAyB1B,OAvBIG,EACFtB,GAAc,WACZU,OAEOa,GACTvB,GAAc,WACZiB,IACAP,OA3Dc,SAACT,EAAqBuB,QAAA,IAAAA,MAAA,KACxC,IAAMC,EAAgBC,kBAAwB,WAAM,YAGpDC,qBAAgB,WACdF,EAAcG,QAAU3B,IACvB,CAACA,IAGJ0B,qBAAgB,WAId,IAAIE,EAAKC,aAHT,WACEL,EAAcG,YAEWJ,GAC3B,OAAO,WAAM,OAAAO,cAAcF,MAC1B,CAACL,IAgDJ,EACE,WACMT,IAAYQ,GACdT,EAASD,EAAQ,KAEfS,GACFR,EAAS,KAGbC,EAAU,SAAOiB,GAGZ,CACLC,KAAM,IAAOC,IAAIf,GACjBgB,MArCY,WAAM,OAAAnB,GAAW,IAsC7BC,KAAI,EACJF,QAAO,IC1DIqB,MApBH,KAAO,MAAD,EACcC,EAAa,CAAE7B,EAAG,GAAK,CAACG,UAAU,EAAMD,OAAQ,IAAM4B,QAAQC,KAAK,gDAAzFJ,EADQ,EACRA,MAAOF,EADC,EACDA,KAAMhB,EADL,EACKA,KACrB,OACE,yBACEuB,MAAO,CACLC,OAAQ,QACRC,MAAO,QACPC,QAAS,OACTC,eAAgB,SAChBC,WAAY,SACZC,cAAe,WAGhBb,EAAKc,OAAO,SACb,4BAAQP,MAAO,CAACQ,UAAW,IAAKC,QAASd,GAAzC,SACA,4BAAQK,MAAO,CAACQ,UAAW,IAAKC,QAAShC,GAAzC,UCbNiC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,U","file":"static/js/main.b2d8c9ec.chunk.js","sourcesContent":["import * as React from \"react\";\nimport moment from \"moment\";\n\nconst useInterval = (callback: () => any, delay: number = 1000) => {\n  const savedCallback = React.useRef<() => any>(() => true);\n\n  // Remember the latest callback.\n  React.useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  React.useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    let id = setInterval(tick, delay);\n    return () => clearInterval(id);\n  }, [delay]);\n};\n\nexport type CountdownInput = { m?: number; s?: number; h?: number } | undefined;\nexport type CountdownConfig = { onDone?: () => any; recuring?: boolean };\n\n// doAfterRender to avoid triggering callback such as alert and halting\n// the ui-thread before time hits 0\nconst doAfterRender = (callback: () => any) => {\n  const timeout = setTimeout(() => {\n    callback();\n    clearTimeout(timeout);\n  }, 1);\n};\n\nexport const useCountdown = (\n  input: CountdownInput = {},\n  config: CountdownConfig = {}\n) => {\n  const { m = 0, s = 0, h = 0 } = input;\n  const { onDone = () => true, recuring = false } = config;\n\n  const [count, setCount] = React.useState(0);\n  const [started, setStarted] = React.useState(false);\n\n  const start = () => setStarted(true);\n  const stop = () => setStarted(false);\n\n  const intervalInMs = h * 60 * 60 * 1000 + m * 60 * 1000 + s * 1000;\n  const diff = intervalInMs - count;\n\n  const remainingDuration = moment.duration(diff, \"milliseconds\");\n  const remainingMilliseconds = remainingDuration.asMilliseconds();\n\n  const shouldReset = started && remainingMilliseconds === 0 && recuring;\n  const isDone = started && remainingMilliseconds === 0;\n\n  if (shouldReset) {\n    doAfterRender(() => {\n      onDone();\n    });\n  } else if (isDone) {\n    doAfterRender(() => {\n      stop();\n      onDone();\n    });\n  }\n\n  useInterval(\n    () => {\n      if (started && !isDone) {\n        setCount(count + 1000);\n      }\n      if (shouldReset) {\n        setCount(0);\n      }\n    },\n    started ? 1000 : undefined\n  );\n\n  return {\n    time: moment.utc(remainingMilliseconds),\n    start,\n    stop,\n    started,\n  };\n};\n","import React from \"react\";\n\nimport { useCountdown } from \"use-moment-countdown\";\n\nconst App = () => {\n  const { start, time, stop } = useCountdown({ s: 1 }, {recuring: true, onDone: () => console.warn(\"You can pass an onDone function like this!\")});\n  return (\n    <div\n      style={{\n        height: \"100vh\",\n        width: \"100vw\",\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        flexDirection: \"column\"\n      }}\n    >\n      {time.format(\"mm:ss\")}\n      <button style={{marginTop: 20}} onClick={start}>Start</button>\n      <button style={{marginTop: 20}} onClick={stop}>Stop</button>\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}